package svd2odin

import "core:fmt"
import "core:os"
import "core:strings"

// Generate linker script and startup assembly
generate_startup_files :: proc(device: Device, memory: Memory_Config, output_dir: string) -> bool {
    // Generate linker script
    if !generate_linker_script(device, memory, output_dir) {
        return false
    }

    // Generate startup assembly
    if !generate_startup_assembly(device, memory, output_dir) {
        return false
    }

    return true
}

// Generate GNU LD linker script
generate_linker_script :: proc(device: Device, memory: Memory_Config, output_dir: string) -> bool {
    filename := fmt.tprintf("%s/%s.ld", output_dir, device.name)
    defer delete(filename)

    sb := strings.builder_make()
    defer strings.builder_destroy(&sb)

    // Header comment
    fmt.sbprintfln(&sb, "/* Linker script for %s */", device.name)
    fmt.sbprintfln(&sb, "/* Generated by svd2odin from %s.svd */\n", device.name)

    // Entry point
    fmt.sbprintfln(&sb, "ENTRY(Reset_Handler)\n")

    // Stack size (8KB default)
    fmt.sbprintfln(&sb, "_estack = ORIGIN(RAM) + LENGTH(RAM); /* Top of stack */\n")

    // Memory regions
    strings.write_string(&sb, "MEMORY\n")
    strings.write_string(&sb, "{\n")
    fmt.sbprintfln(&sb, "  FLASH (rx)  : ORIGIN = 0x%08X, LENGTH = %dK",
        memory.flash_origin, memory.flash_size / 1024)
    fmt.sbprintfln(&sb, "  RAM (rwx)   : ORIGIN = 0x%08X, LENGTH = %dK",
        memory.ram_origin, memory.ram_size / 1024)
    strings.write_string(&sb, "}\n\n")

    // Sections
    strings.write_string(&sb, "SECTIONS\n")
    strings.write_string(&sb, "{\n")

    // .text section (code)
    strings.write_string(&sb, "  .text :\n")
    strings.write_string(&sb, "  {\n")
    strings.write_string(&sb, "    KEEP(*(.isr_vector))\n")
    strings.write_string(&sb, "    *(.text*)\n")
    strings.write_string(&sb, "    *(.rodata*)\n")
    strings.write_string(&sb, "    . = ALIGN(4);\n")
    strings.write_string(&sb, "  } >FLASH\n\n")

    // ARM exception index (for C++ exceptions and stack unwinding)
    strings.write_string(&sb, "  .ARM.exidx :\n")
    strings.write_string(&sb, "  {\n")
    strings.write_string(&sb, "    __exidx_start = .;\n")
    strings.write_string(&sb, "    *(.ARM.exidx* .gnu.linkonce.armexidx.*)\n")
    strings.write_string(&sb, "    __exidx_end = .;\n")
    strings.write_string(&sb, "  } >FLASH\n\n")

    // .data section (initialized data)
    strings.write_string(&sb, "  .data :\n")
    strings.write_string(&sb, "  {\n")
    strings.write_string(&sb, "    _sdata = .;\n")
    strings.write_string(&sb, "    *(.data*)\n")
    strings.write_string(&sb, "    . = ALIGN(4);\n")
    strings.write_string(&sb, "    _edata = .;\n")
    strings.write_string(&sb, "  } >RAM AT>FLASH\n\n")

    strings.write_string(&sb, "  _sidata = LOADADDR(.data);\n\n")

    // .bss section (uninitialized data)
    strings.write_string(&sb, "  .bss :\n")
    strings.write_string(&sb, "  {\n")
    strings.write_string(&sb, "    _sbss = .;\n")
    strings.write_string(&sb, "    *(.bss*)\n")
    strings.write_string(&sb, "    *(COMMON)\n")
    strings.write_string(&sb, "    . = ALIGN(4);\n")
    strings.write_string(&sb, "    _ebss = .;\n")
    strings.write_string(&sb, "  } >RAM\n\n")

    strings.write_string(&sb, "}\n")

    // Write to file
    if !os.write_entire_file(filename, transmute([]u8)strings.to_string(sb)) {
        fmt.eprintfln("Failed to write linker script: %s", filename)
        return false
    }

    fmt.printfln("Generated: %s", filename)
    return true
}

// Generate ARM assembly startup file
generate_startup_assembly :: proc(device: Device, memory: Memory_Config, output_dir: string) -> bool {
    filename := fmt.tprintf("%s/startup_%s.s", output_dir, strings.to_lower(device.name))
    defer delete(filename)

    sb := strings.builder_make()
    defer strings.builder_destroy(&sb)

    // Header
    fmt.sbprintfln(&sb, "/* Startup code for %s */", device.name)
    fmt.sbprintfln(&sb, "/* Generated by svd2odin from %s.svd */\n", device.name)

    // Syntax and CPU
    fmt.sbprintfln(&sb, ".syntax unified")
    cpu_arch := get_cpu_arch(device.cpu.name)
    fmt.sbprintfln(&sb, ".cpu %s", cpu_arch)
    fmt.sbprintfln(&sb, ".thumb\n")

    // External symbols
    fmt.sbprintfln(&sb, ".extern app_main")
    fmt.sbprintfln(&sb, ".extern _estack\n")

    // Vector table
    fmt.sbprintfln(&sb, ".section .isr_vector, \"a\"")
    fmt.sbprintfln(&sb, ".global g_pfnVectors")
    fmt.sbprintfln(&sb, ".type g_pfnVectors, %%object\n")

    fmt.sbprintfln(&sb, "g_pfnVectors:")
    fmt.sbprintfln(&sb, "  .word _estack                    /* Stack pointer */")
    fmt.sbprintfln(&sb, "  .word Reset_Handler              /* Reset */")
    fmt.sbprintfln(&sb, "  .word NMI_Handler                /* NMI */")
    fmt.sbprintfln(&sb, "  .word HardFault_Handler          /* Hard Fault */")
    fmt.sbprintfln(&sb, "  .word MemManage_Handler          /* Memory Management */")
    fmt.sbprintfln(&sb, "  .word BusFault_Handler           /* Bus Fault */")
    fmt.sbprintfln(&sb, "  .word UsageFault_Handler         /* Usage Fault */")
    fmt.sbprintfln(&sb, "  .word 0                          /* Reserved */")
    fmt.sbprintfln(&sb, "  .word 0                          /* Reserved */")
    fmt.sbprintfln(&sb, "  .word 0                          /* Reserved */")
    fmt.sbprintfln(&sb, "  .word 0                          /* Reserved */")
    fmt.sbprintfln(&sb, "  .word SVC_Handler                /* SVCall */")
    fmt.sbprintfln(&sb, "  .word DebugMon_Handler           /* Debug Monitor */")
    fmt.sbprintfln(&sb, "  .word 0                          /* Reserved */")
    fmt.sbprintfln(&sb, "  .word PendSV_Handler             /* PendSV */")
    fmt.sbprintfln(&sb, "  .word SysTick_Handler            /* SysTick */\n")

    // IRQ vectors - must be in order by IRQ number with no gaps
    fmt.sbprintfln(&sb, "  /* External interrupts */")

    // Find max IRQ number and build a map
    max_irq: u32 = 0
    for interrupt in device.interrupts {
        if interrupt.value > max_irq {
            max_irq = interrupt.value
        }
    }

    // Generate vector entries in order
    for irq: u32 = 0; irq <= max_irq; irq += 1 {
        // Find interrupt with this IRQ number
        found := false
        for interrupt in device.interrupts {
            if interrupt.value == irq {
                fmt.sbprintfln(&sb, "  .word %s_IRQHandler              /* %d: %s */",
                    interrupt.name, interrupt.value, interrupt.description)
                found = true
                break
            }
        }
        if !found {
            fmt.sbprintfln(&sb, "  .word Default_Handler            /* %d: Reserved */", irq)
        }
    }

    fmt.sbprintfln(&sb, "\n.size g_pfnVectors, .-g_pfnVectors\n")

    // Reset handler
    fmt.sbprintfln(&sb, "/* Reset handler */")
    fmt.sbprintfln(&sb, ".section .text.Reset_Handler")
    fmt.sbprintfln(&sb, ".weak Reset_Handler")
    fmt.sbprintfln(&sb, ".type Reset_Handler, %%function")
    fmt.sbprintfln(&sb, "Reset_Handler:")
    fmt.sbprintfln(&sb, "  ldr r0, =_estack")
    fmt.sbprintfln(&sb, "  mov sp, r0\n")

    // Copy .data from flash to RAM
    fmt.sbprintfln(&sb, "  /* Copy .data section from flash to RAM */")
    fmt.sbprintfln(&sb, "  ldr r0, =_sdata")
    fmt.sbprintfln(&sb, "  ldr r1, =_edata")
    fmt.sbprintfln(&sb, "  ldr r2, =_sidata")
    fmt.sbprintfln(&sb, "  movs r3, #0")
    fmt.sbprintfln(&sb, "  b LoopCopyDataInit\n")

    fmt.sbprintfln(&sb, "CopyDataInit:")
    fmt.sbprintfln(&sb, "  ldr r4, [r2, r3]")
    fmt.sbprintfln(&sb, "  str r4, [r0, r3]")
    fmt.sbprintfln(&sb, "  adds r3, r3, #4\n")

    fmt.sbprintfln(&sb, "LoopCopyDataInit:")
    fmt.sbprintfln(&sb, "  adds r4, r0, r3")
    fmt.sbprintfln(&sb, "  cmp r4, r1")
    fmt.sbprintfln(&sb, "  bcc CopyDataInit\n")

    // Zero-init .bss
    fmt.sbprintfln(&sb, "  /* Zero .bss section */")
    fmt.sbprintfln(&sb, "  ldr r2, =_sbss")
    fmt.sbprintfln(&sb, "  ldr r4, =_ebss")
    fmt.sbprintfln(&sb, "  movs r3, #0")
    fmt.sbprintfln(&sb, "  b LoopFillZerobss\n")

    fmt.sbprintfln(&sb, "FillZerobss:")
    fmt.sbprintfln(&sb, "  str r3, [r2]")
    fmt.sbprintfln(&sb, "  adds r2, r2, #4\n")

    fmt.sbprintfln(&sb, "LoopFillZerobss:")
    fmt.sbprintfln(&sb, "  cmp r2, r4")
    fmt.sbprintfln(&sb, "  bcc FillZerobss\n")

    // Call app_main
    fmt.sbprintfln(&sb, "  /* Call app_main */")
    fmt.sbprintfln(&sb, "  bl app_main")
    fmt.sbprintfln(&sb, "  b .\n")

    fmt.sbprintfln(&sb, ".size Reset_Handler, .-Reset_Handler\n")

    // Default handlers (weak, infinite loop)
    fmt.sbprintfln(&sb, "/* Default interrupt handlers */")
    fmt.sbprintfln(&sb, ".section .text.Default_Handler, \"ax\", %%progbits")
    fmt.sbprintfln(&sb, "Default_Handler:")
    fmt.sbprintfln(&sb, "  b .")
    fmt.sbprintfln(&sb, ".size Default_Handler, .-Default_Handler\n")

    // Weak aliases for all handlers
    fmt.sbprintfln(&sb, "/* Weak aliases */")
    fmt.sbprintfln(&sb, ".weak NMI_Handler")
    fmt.sbprintfln(&sb, ".thumb_set NMI_Handler, Default_Handler\n")

    fmt.sbprintfln(&sb, ".weak HardFault_Handler")
    fmt.sbprintfln(&sb, ".thumb_set HardFault_Handler, Default_Handler\n")

    fmt.sbprintfln(&sb, ".weak MemManage_Handler")
    fmt.sbprintfln(&sb, ".thumb_set MemManage_Handler, Default_Handler\n")

    fmt.sbprintfln(&sb, ".weak BusFault_Handler")
    fmt.sbprintfln(&sb, ".thumb_set BusFault_Handler, Default_Handler\n")

    fmt.sbprintfln(&sb, ".weak UsageFault_Handler")
    fmt.sbprintfln(&sb, ".thumb_set UsageFault_Handler, Default_Handler\n")

    fmt.sbprintfln(&sb, ".weak SVC_Handler")
    fmt.sbprintfln(&sb, ".thumb_set SVC_Handler, Default_Handler\n")

    fmt.sbprintfln(&sb, ".weak DebugMon_Handler")
    fmt.sbprintfln(&sb, ".thumb_set DebugMon_Handler, Default_Handler\n")

    fmt.sbprintfln(&sb, ".weak PendSV_Handler")
    fmt.sbprintfln(&sb, ".thumb_set PendSV_Handler, Default_Handler\n")

    fmt.sbprintfln(&sb, ".weak SysTick_Handler")
    fmt.sbprintfln(&sb, ".thumb_set SysTick_Handler, Default_Handler\n")

    // IRQ handler aliases
    for interrupt in device.interrupts {
        fmt.sbprintfln(&sb, ".weak %s_IRQHandler", interrupt.name)
        fmt.sbprintfln(&sb, ".thumb_set %s_IRQHandler, Default_Handler\n", interrupt.name)
    }

    // Write to file
    if !os.write_entire_file(filename, transmute([]u8)strings.to_string(sb)) {
        fmt.eprintfln("Failed to write startup file: %s", filename)
        return false
    }

    fmt.printfln("Generated: %s", filename)
    return true
}

// Map CPU name to GCC architecture
get_cpu_arch :: proc(cpu_name: string) -> string {
    switch cpu_name {
    case "CM0", "CM0+":
        return "cortex-m0"
    case "CM3":
        return "cortex-m3"
    case "CM4":
        return "cortex-m4"
    case "CM7":
        return "cortex-m7"
    case "CM33":
        return "cortex-m33"
    case:
        return "cortex-m4"  // Default fallback
    }
}
